#!/usr/bin/env python
# 
# Pentest Script Version 1.0.0 (2022)
#
# This tool may be used for legal purposes only.  Users take full responsibility
# for any actions performed using this tool. The author accepts no liability for
# damage caused by this tool.  If these terms are not acceptable to you, then do 
# not use this tool.
# 
# by Pierre CHAUSSARD
# 
# 08-Feb-2022 - 1.0.0 - Creating basic script.
# 10-Feb-2022 - 1.0.1 - Adding port scanner function.
# 14-Feb-2022 - 1.0.2 - Updating port scanner function + others functions.
# 21-Mar-2022 - 1.1.0 - Transform code into oop project + adding account finder.
# 22-Mar-2022 - 1.1.1 - Adding ssh bruteforce.
# 23-Mar-2022 - 1.1.2 - Transform finder as class.
#               1.1.3 - Script optimization.
# 

import sys, os, pyfiglet, requests, socket, json, hashlib, time, paramiko
from datetime import datetime
from threading import Thread
from finder import Finder
from ftplib import FTP

#"Choose your service :\n 1. IP from hostname.\n 2. Port Scanner.\n 3. Nmap Scanner.\n 4. Subdomain Enumeration.\n 5. Directory Enumeration.\n 6. Hash Cracker.\n 7. SSH BruteForce.\n 8. Account Finder.\n>"
class Main():
    def __init__(self):
        self.state = True
        self.options = {
            "1": [1, " 1. IP from hostname.", self.ip_hostname],
            "2": [2, " 2. Port Scanner.", self.port_scanner],
            "3": [3, " 3. Nmap Scanner.", self.nmap_scanner],
            "4": [4, " 4. Subdomain Enumeration.", self.subdomain_enum],
            "5": [5, " 5. Directory Enumeration.", self.directory_enum],
            "6": [6, " 6. Hash Cracker.", self.hash_cracker],
            "7": [7, " 7. SSH BruteForce.", self.ssh_bruteforce],
            "8": [8, " 8. FTP BruteForce.", self.ftp_bruteforce],
            "9": [9, " 9. Account Finder.", self.account_finder],
        }

    def section_print(self, title):
        print("\n" + "=" * 50)
        print(title)
        print("=" * 50 + "\n")

    def ip_hostname(self):
        self.section_print("GET IP FROM HOSTNAME")
        host_to_resolve = input("Enter hostname to resolve :\n>")
        ip = socket.gethostbyname(host_to_resolve)
        print(f"Resolved !\n |  Hostname : {host_to_resolve}.\n |_ IP : {ip}")
        input("\nPress Enter to continue...")

    def subdomain_enum(self):
        self.section_print("SUBDOMAIN TO ENUMERATE")
        sub_to_enum = input("Enter hostname enumerate :\n>")
        sub_list = open("wordlists/subdomain.txt").read() 
        subdoms = sub_list.splitlines()

        print("\nValide domains :")

        for sub in subdoms:
            sub_domains = f"http://{sub}.{sub_to_enum}"

            try:
                requests.get(sub_domains)
            
            except requests.ConnectionError: 
                pass          
            else:
                print(" | ", sub_domains)
        print(" |_ Done !")
        input("\nPress Enter to continue...")
    
    def directory_enum(self):
        self.section_print("DIRECTORY TO ENUMERATE")
        dir_to_enum = input("Enter hostname/IP to enumarate :\n>")
        print('\n')
        sub_list = open("wordlists/directory-list-low.txt").read()
        directories = sub_list.splitlines()
        target = socket.gethostbyname(dir_to_enum)

        for dir in directories:
            dir_enum = f"http://{target}/{dir}.html"
            r = requests.get(dir_enum)
            if r.status_code == 404:
                pass
            else:
                print("Valid directory:" , dir_enum)
        input("\nPress Enter to continue...")

    def port_scanner(self):
        self.section_print("PORT SCANNER")
        host_to_scan = input("Enter host to scan :\n>")

        print("\n" + "-" * 50)
        print("Scanning Target: " + host_to_scan)
        print("Scanning started at: " + str(datetime.now()))
        print("-" * 50)
        
        with open('wordlists/tcp-port.json') as json_data:
            data_dict = json.load(json_data)

        for port in data_dict:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            socket.setdefaulttimeout(0.0000001)

            state = s.connect_ex((host_to_scan,port['port']))
            if state == 0:
                print(f"{port['port']}/tcp\n |  State : OPEN.\n |  Service : {port['service']}.\n |_ Description : {port['description']}.")
            s.close()

        f = open(f"src/{host_to_scan}.log", "a")
        #f.write(ascii_banner)
        f.write("-" * 50 + "\n")
        f.write("Scanning Target: " + host_to_scan + "\n")
        f.write("Scanning started at: " + str(datetime.now()) + "\n")
        f.write("-" * 50 + "\n")

        for port in data_dict:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            socket.setdefaulttimeout(0.0000001)

            state = s.connect_ex((host_to_scan,port['port']))
            if state == 0:
                f.write(f"{port['port']}/tcp\n |  State : OPEN.\n |  Service : {port['service']}.\n |_ Description : {port['description']}.\n")
            s.close()
        f.close()
        print("\nFile Saved !")

        input("\nPress Enter to continue...")

    def nmap_scanner(self):
        pass

    def hash_cracker(self):
        self.section_print("HASH CRACKER")
        # path = 'wordlists/'
        # files = os.listdir(path)
        # for f in files:
        #     print(f)

        wordlist_location = str(input("Enter wordlist file location [name.ext] :\n>"))
        hash_type = str(input("Enter hash type [md5, sha256] :\n>"))
        hash_input = str(input("Enter hash to be cracked :\n>"))

        with open(f"wordlists\{wordlist_location}", 'r') as file:
            start = time.time()
            for line in file.readlines():
                if hash_type == 'md5':
                    hash_ob = hashlib.md5(line.strip().encode())
                elif hash_type == 'sha256':
                    hash_ob = hashlib.sha256(line.strip().encode())
                
                hashed_pass = hash_ob.hexdigest()
                if hashed_pass == hash_input:
                    end = time.time()
                    print(f"Hash Cracker\n |  Wordlist : {wordlist_location}.\n |  Hash Type : {hash_type}.\n |  Hash : {hash_input}.\n |  Password founded : {line.strip()}\n |_ Time elapsed : {end - start}s.")
                    exit(0)

    def ssh_connect(ip, username, password, port=22):
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(ip, port, username, password)
            print("Mot de passe: " + password)
            return True
        except:
            return False

    def ssh_bruteforce(self):
        ip = str(input("Enter SSH IP :\n>"))
        user = str(input("Enter username :\n>"))
        wordl = str(input("Enter wordlist (just the filename, not the ext.) :\n>"))

        arr = []
        with open(f"wordlists\{wordl}.txt", 'r', encoding = "utf8") as file:
            for line in file.readlines():
                th = Thread(target = self.ssh_connect ,args = (ip, user, line.strip()))
                th.start()

        input("\nPress Enter to continue...")

    def ftp_connect(self, ip, user, password):
        try:
                FTP(ip, user = user, passwd = password)
                print("Mot de passe: " + password)
                return True
        except:
                print("echec: " + password)
                return False

    def ftp_bruteforce(self, ip, username, wordlist):
        arr = []
        with open(f"wordlists\{wordlist}.txt", 'r', encoding="utf8") as file:
            for line in file.readlines():
                th = Thread(target=self.ftp_connect ,args=(ip, username, line.strip()))
                th.start()

    def account_finder(self):
        response = []
        email = str(input("\nEnter Email to scan :\n>"))

        print("-" * 50)
        print("Scanning Target: " + email)
        print("Scanning started at: " + str(datetime.now()))
        print("-" * 50)

        start = time.time()

        finder = Finder()
        for service in finder.services:
            response.append(service(email))

        finder.close()

        print(response)

        end = time.time()
        print(f"Fin du programme, temps d'execution : {end - start}s")
        input("\nPress Enter to continue...")

    def print_menu(self):
        ascii_banner = pyfiglet.figlet_format("PENTEST.PY")
        print(ascii_banner)
        print("=" * 58)
        print("This tool may be used for legal purposes only. \nUsers take full responsibility for any actions performed \nusing this tool. The author accepts no liability for \ndamage caused by this tool.  If these terms are not \nacceptable to you, then do not use this tool.")
        print("\nTool developed by Pierre CHAUSSARD.")
        print("=" * 58)
        for i in self.options:
            print(self.options["{}".format(i)][1])
        choice = int(input(">"))
        
        while not 0 < choice <= len(self.options):
            print("\n[x] Please select a number between {} and {}...\n".format(1, len(self.options)))
            for i in self.options:
                print(self.options["{}".format(i)][1])
            choice = int(input(">"))
        
        for i in self.options:
            if choice == self.options["{}".format(i)][0]:
                self.options["{}".format(i)][2]()


if __name__ == '__main__':    
    try:
        main = Main()
        while main.state:
            main.print_menu()

    except KeyboardInterrupt:
        print("\n[x] Exiting Program !")
        sys.exit()
    except socket.gaierror:
        print("\n[!] Hostname Could Not Be Resolved !")
        sys.exit()