#!/usr/bin/env python
# 
# Pentest Script Version 1.1.6 (2022)
#
# This tool may be used for legal purposes only.  Users take full responsibility
# for any actions performed using this tool. The author accepts no liability for
# damage caused by this tool.  If these terms are not acceptable to you, then do 
# not use this tool.
# 
# by Pierre CHAUSSARD
# 
# 08-Feb-2022 - 1.0.0 - [Add] Basic script.
# 10-Feb-2022 - 1.0.1 - [Add] Port scanner function.
# 14-Feb-2022 - 1.0.2 - [Upd] Port scanner function + others functions.
# 21-Mar-2022 - 1.1.0 - [Upd] Code into oop project + [Add] account finder.
# 22-Mar-2022 - 1.1.1 - [Add] Ssh bruteforce.
# 23-Mar-2022 - 1.1.2 - [Upd] Finder as class.
#               1.1.3 - [Add] Script optimization.
# 24-Mar-2022 - 1.1.4 - [Upd] Hash cracker.
# 31-Mar-2022 - 1.1.5 - [Add] Email finder.
# 01-Apr-2022 - 1.1.6 - [Add] Email scanner.
# 

import sys, os, pyfiglet, requests, socket, json, hashlib, time, paramiko
from validate_email import validate_email
from datetime import datetime
from threading import Thread
from finder import Finder
from ftplib import FTP


class Main():
    def __init__(self):
        self.state = True
        self.options = {
            "1": [1, " 1. IP from hostname.", self.ip_hostname],
            "2": [2, " 2. Port Scanner.", self.port_scanner],
            "3": [3, " 3. Nmap Scanner.", self.nmap_scanner],
            "4": [4, " 4. Subdomain Enumeration.", self.subdomain_enum],
            "5": [5, " 5. Directory Enumeration.", self.directory_enum],
            "6": [6, " 6. Hash Cracker.", self.hash_cracker],
            "7": [7, " 7. SSH BruteForce.", self.ssh_bruteforce],
            "8": [8, " 8. FTP BruteForce.", self.ftp_bruteforce],
            "9": [9, " 9. Account Finder.", self.account_finder],
            "10": [10, " 10. Email Finder.", self.email_finder],
            "11": [11, " 11. Email Scaner.", self.email_scanner],
            "12": [12, " 12. EXIT.", sys.exit],
        }

    def section_print(self, title):
        print("\n" + "=" * 58)
        print(title)
        print("=" * 58 + "\n")

    def ip_hostname(self):
        self.section_print("GET IP FROM HOSTNAME")
        host_to_resolve = input("Enter hostname to resolve :\n>")
        ip = socket.gethostbyname(host_to_resolve)
        print(f"Resolved !\n |  Hostname : {host_to_resolve}.\n |_ IP : {ip}")
        input("\nPress Enter to continue...")

    def subdomain_enum(self):
        self.section_print("SUBDOMAIN TO ENUMERATE")
        sub_to_enum = input("Enter hostname enumerate :\n>")
        sub_list = open("wordlists/subdomain.txt").read() 
        subdoms = sub_list.splitlines()

        print("\nValide domains :")

        for sub in subdoms:
            sub_domains = f"http://{sub}.{sub_to_enum}"

            try:
                requests.get(sub_domains)
            
            except requests.ConnectionError: 
                pass          
            else:
                print(" | ", sub_domains)
        print(" |_ Done !")
        input("\nPress Enter to continue...")
    
    def directory_enum(self):
        self.section_print("DIRECTORY TO ENUMERATE")
        dir_to_enum = input("Enter hostname/IP to enumarate :\n>")
        print('\n')
        sub_list = open("wordlists/directory-list-low.txt").read()
        directories = sub_list.splitlines()
        target = socket.gethostbyname(dir_to_enum)

        for dir in directories:
            dir_enum = f"http://{target}/{dir}.html"
            r = requests.get(dir_enum)
            if r.status_code == 404:
                pass
            else:
                print("Valid directory:" , dir_enum)
        input("\nPress Enter to continue...")

    def port_scanner(self):
        self.section_print("PORT SCANNER")
        host_to_scan = input("Enter host to scan :\n>")

        print("\n" + "-" * 50)
        print("Scanning Target: " + host_to_scan)
        print("Scanning started at: " + str(datetime.now()))
        print("-" * 50)
        
        with open('wordlists/tcp-port.json') as json_data:
            data_dict = json.load(json_data)

        for port in data_dict:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            socket.setdefaulttimeout(0.0000001)

            state = s.connect_ex((host_to_scan,port['port']))
            if state == 0:
                print(f"{port['port']}/tcp\n |  State : OPEN.\n |  Service : {port['service']}.\n |_ Description : {port['description']}.")
            s.close()

        f = open(f"src/{host_to_scan}.log", "a")
        #f.write(ascii_banner)
        f.write("-" * 50 + "\n")
        f.write("Scanning Target: " + host_to_scan + "\n")
        f.write("Scanning started at: " + str(datetime.now()) + "\n")
        f.write("-" * 50 + "\n")

        for port in data_dict:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            socket.setdefaulttimeout(0.0000001)

            state = s.connect_ex((host_to_scan,port['port']))
            if state == 0:
                f.write(f"{port['port']}/tcp\n |  State : OPEN.\n |  Service : {port['service']}.\n |_ Description : {port['description']}.\n")
            s.close()
        f.close()
        print("\nFile Saved !")

        input("\nPress Enter to continue...")

    def nmap_scanner(self):
        pass

    def hash_cracker(self):
        self.section_print("HASH CRACKER")
        path = 'wordlists/'
        files = os.listdir(path)
        wordlist = []
        for f in files:
            wordlist.append(f)
        print(f"Wordlists : {wordlist}.")
        wordlist_location = str(input("Enter wordlist file name [name.ext] :\n>"))
        hash_type = str(input("Enter hash type [md5, sha256] :\n>"))
        hash_input = str(input("Enter hash to be cracked :\n>"))

        with open(f"wordlists\{wordlist_location}", 'r', encoding="utf8") as file:
            start = time.time()
            for line in file.readlines():
                if hash_type == 'md5':
                    hash_ob = hashlib.md5(line.strip().encode())
                elif hash_type == 'sha256':
                    hash_ob = hashlib.sha256(line.strip().encode())
                
                hashed_pass = hash_ob.hexdigest()
                if hashed_pass == hash_input:
                    end = time.time()
                    print(f"Hash Cracker\n |  Wordlist : {wordlist_location}.\n |  Hash Type : {hash_type}.\n |  Hash : {hash_input}.\n |  Password founded : {line.strip()}\n |_ Time elapsed : {end - start}s.")
                    input("\nPress Enter to continue...")

    def ssh_connect(ip, username, password, port = 22):
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(ip, port, username, password)
            print("Mot de passe: " + password)
            return True
        except:
            return False

    def ssh_bruteforce(self):
        ip = str(input("Enter SSH IP :\n>"))
        user = str(input("Enter username :\n>"))
        wordl = str(input("Enter wordlist (just the filename, not the ext.) :\n>"))

        arr = []
        with open(f"wordlists\{wordl}.txt", 'r', encoding = "utf8") as file:
            for line in file.readlines():
                th = Thread(target = self.ssh_connect ,args = (ip, user, line.strip()))
                th.start()

        input("\nPress Enter to continue...")

    def ftp_connect(self, ip, user, password):
        try:
                FTP(ip, user = user, passwd = password)
                print("Mot de passe: " + password)
                return True
        except:
                print("echec: " + password)
                return False

    def ftp_bruteforce(self, ip, username, wordlist):
        arr = []
        with open(f"wordlists\{wordlist}.txt", 'r', encoding="utf8") as file:
            for line in file.readlines():
                th = Thread(target=self.ftp_connect ,args=(ip, username, line.strip()))
                th.start()

    def account_finder(self):
        response = []
        email = str(input("\nEnter Email to scan :\n>"))

        print("-" * 50)
        print("Scanning Target: " + email)
        print("Scanning started at: " + str(datetime.now()))
        print("-" * 50)

        start = time.time()

        finder = Finder()
        for service in finder.services:
            response.append(service(email))

        finder.close()

        print(response)

        end = time.time()
        print(f"Fin du programme, temps d'execution : {end - start}s")
        input("\nPress Enter to continue...")

    def generate_email(self, first_name, last_name, company = None):
        names = []
        names.append(f"{first_name}.{last_name}")
        names.append(f"{last_name}.{first_name}")
        names.append(f"{first_name}{last_name}")
        names.append(f"{last_name}{first_name}")
        names.append(f"{first_name[0]}.{last_name}")
        names.append(f"{first_name[0]}{last_name}")

        domains = []
        for name in names:
            domains_name = ["gmail", "yahoo", "outlook", "hotmail", "orange","free"]
            if company:
                domains_name.append(company)
            for domain in domains_name:
                domains.append(f"{name}@{domain}")

        emails = []
        for domain in domains:
            for net in ["fr", "com", "org", "net"]:
                if not (net in ["fr", "org", "net"] and "google" in domain):
                    emails.append(f"{domain}.{net}")

        return emails

    def email_exist(self, email):
        is_valid = validate_email(email, verify=True)
        return is_valid

    def email_finder(self):
        self.section_print("EMAIL FINDER")
        while 1:
            choice = int(input("Select the generation's options :\n 1. Manual (Firstname + Lastname + company [optional]).\n 2. Automatic (using file [txt] => json file).\n>"))
            if choice == 1:
                firstname = str(input("Firstname : "))
                lastname = str(input("Lastname : "))
                company = str(input("Company (press ENTER if unknowned) : "))
                email_list = self.generate_email(firstname, lastname, company)
                # print(email_list)
                i = valid = 0
                start = time.time()
                with open(f"src/valid_email_for_{firstname}_{lastname}_{company}.txt", 'w') as file:
                    for email in email_list:
                        i += 1
                        if self.email_exist(email):
                            print("[{}/{}] Valid: {}".format(i, len(email_list), email))
                            file.write(email + "\n")
                            valid += 1
                        else:
                            print("[{}/{}] Invalid: {}".format(i, len(email_list), email))
                    end = time.time()
                    print("Founded {}/{} valid emails in {} minutes.".format(valid, len(email_list), (end - start)/60))
                    input("\nPress Enter to continue...")
                    break
            elif choice == 2:
                input("\nComing Soon... Press Enter to continue...")
                break
            else:
                print("\n[x] Please select a number between 1 and 2...\n")

    def email_scanner(self):
        self.section_print("EMAIL SCANNER")
        finder = Finder()
        email = str(input("Enter email to scan : "))
        finder.firefox_monitor(email)
        input("\nPress Enter to continue...")

    def print_menu(self):
        ascii_banner = pyfiglet.figlet_format("PENTEST.PY")
        print(ascii_banner)
        print("=" * 58)
        print("This tool may be used for legal purposes only. \nUsers take full responsibility for any actions performed \nusing this tool. The author accepts no liability for \ndamage caused by this tool.  If these terms are not \nacceptable to you, then do not use this tool.")
        print("\nTool developed by Pierre CHAUSSARD.")
        print("=" * 58)
        for i in self.options:
            print(self.options["{}".format(i)][1])
        choice = int(input(">"))
        
        while not 0 < choice <= len(self.options):
            print("\n[x] Please select a number between {} and {}...\n".format(1, len(self.options)))
            for i in self.options:
                print(self.options["{}".format(i)][1])
            choice = int(input(">"))
        
        for i in self.options:
            if choice == self.options["{}".format(i)][0]:
                try:
                    self.options["{}".format(i)][2]()
                except KeyboardInterrupt:
                    pass


if __name__ == '__main__':    
    try:
        main = Main()
        while main.state:
            main.print_menu()

    except KeyboardInterrupt:
        print("\n[x] Exiting Program !")
        sys.exit()
    except socket.gaierror:
        print("\n[!] Hostname Could Not Be Resolved !")
        sys.exit()
